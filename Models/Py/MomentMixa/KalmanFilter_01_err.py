
# https://filterpy.readthedocs.io/en/latest/kalman/KalmanFilter.html
# KalmanFilter
import numpy as np
from filterpy.kalman import KalmanFilter
f = KalmanFilter (dim_x=2, dim_z=1)

#Назначьте начальное значение для состояния (положения и скорости).
# Вы можете сделать это с помощью двумерного массива следующим образом:
f.x = np.array([[2.],    # position
                [0.]])   # velocity

#или просто используйте одномерный массив, что я предпочитаю делать.
f.x = np.array([2., 0.])

# Определите матрицу перехода состояний:
f.F = np.array([[1.,1.],
                [0.,1.]])

# Определите функцию измерения:
f.H = np.array([[1.,0.]])

#Задайте ковариационную матрицу. Здесь я использую тот факт, что P уже содержит np.eye(dim_x),
# и просто умножаю на неопределенность:
f.P *= 1000.

# Я мог бы написать:
f.P = np.array([[1000.,    0.],
                [   0., 1000.] ])
#  Вам решать, что более читабельно и понятно.

# Теперь назначьте шум измерения. Здесь размер 1x1, поэтому я могу использовать скаляр
f.R = 5
# Я мог бы сделать это вместо этого:
f.R = np.array([[5.]])
# Обратите внимание, что это должен быть двумерный массив, как и все матрицы.

# Наконец, я назначу шум процесса. Здесь я воспользуюсь другой функцией библиотеки FilterPy:

from filterpy.common import Q_discrete_white_noise
f.Q = Q_discrete_white_noise(dim=2, dt=0.1, var=0.13)
# Теперь просто выполните стандартный цикл прогнозирования/обновления:

#в то время как some_condition_is_true:

z = get_sensor_reading()
f.predict()
f.update(z)

do_something_with_estimate (f.x)
